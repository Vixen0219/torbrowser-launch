#!/usr/bin/gjs

const Gtk = imports.gi.Gtk;
const Gio = imports.gi.Gio;
const GLib = imports.gi.GLib;
const Soup = imports.gi.Soup;
const Lang = imports.lang;

const TorBrowserLauncher = new Lang.Class({
  Name: 'Tor Borwser Launcher',

  // create the application
  _init: function(current_tbb_version) {
    let that = this;

    // initialize the app
    this._current_tbb_version = current_tbb_version;
    this._discover_arch_lang();
    this._build_paths();
    this._mkdirs();
    
    let launch_gui = true;

    // is TBB already installed?
    if(this._file_executable(this._paths.file.start)) {

      // does the version file exist?
      if(this._file_exists(this._paths.file.version)) {

        let installed_tbb_version = this._read_version_file();
        if(installed_tbb_version) {
          if(installed_tbb_version == this._current_tbb_version) {
            // current version is tbb is installed, launch it
            that._exec([that._paths.file.start]);
            launch_gui = false;
          } else if(installed_tbb_version < that._current_tbb_version) {
            // there is a tbb upgrade available
            that._set_gui('task',
              "Your Tor Browser Launcher is out of date. Click Start to download the\n"+
              "following files from https://www.torproject.org:\n\n"+
              that._paths.filename.tarball+"\n"+
              that._paths.filename.tarball_sig+"\n",
              ['download_tarball', 'download_tarball_sig', 'verify', 'extract', 'run']);
          } else {
            // for some reason the installed tbb is newer than the current version?
            that._set_gui('error', 
              "Something is wrong. The version of Tor Browser Bundle\n"+
              "you have installed is newer than the current version?");
          }
        } else {
          // error reading version from file
          that._set_gui('error', 
            "Tor Browser Launcher couldn't read this file:\n\n"+this._paths.dir.version);
        };
      
      } else {
        // if tbb is installed but the version file doesn't exist, something is wrong
        this._set_gui('error', 
          "Something is wrong. You have the Tor Browser Bundle\n"+
          "installed, but the version file is missing.");
      }
    } else {

      // save the current version to the file
      this._write_version_file(this._current_tbb_version);

      // is the tarball and sig already downloaded?
      if(this._file_exists(this._paths.file.tarball) &&
        this._file_exists(this._paths.file.tarball_sig)) {

        // verify it's signature
        this._verify_sig(null, null, function(err){
          if(err) {
            // signature verification failed
            this._set_gui('error', 
              "Something is wrong. The Tor Browser Bundle that you\n"+
              "were about to install does not have a valid signature.\n"+
              "Deleting this directory and try again:\n\n"+
              this._paths.dir.download);

          } else {
            
            // start the gui with extract
            this._set_gui('task', 
              "You already have Tor Browser Bundle downloaded, but\n"+
              "it isn't installed yet.", 
              ['extract', 'run']);

          }
        });

      } else {

        // first run
        this._set_gui('task',
          "The first time you run the Tor Browser Launcher you need to download\n"+
          "the Tor Browser Bundle. Click start to download it now from the\n"+
          "following files from https://www.torproject.org/:\n\n"+
          this._paths.filename.tarball+"\n"+
          this._paths.filename.tarball_sig+"\n",
          ['download_tarball', 'download_tarball_sig', 'verify', 'extract', 'run']);
      }
    }

    if(launch_gui) {
      // start an http session to make http requests
      this._httpSession = new Soup.SessionAsync();
      Soup.Session.prototype.add_feature.call(this._httpSession, new Soup.ProxyResolverDefault());

      // create the application
      this.application = new Gtk.Application();

      // connect 'activate' and 'startup' signals to the callback functions
      this.application.connect('activate', Lang.bind(this, function(){
        this._window.present();
      }));
      this.application.connect('startup', Lang.bind(this, function(){
        this._build_ui();
      }));

      // run the application
      this.application.run(ARGV);
    }
  },

  // discover the architecture and language
  _discover_arch_lang: function(){
    // get the architecture
    let [res, out] = this._exec(['arch']);
    this._architecture = (''+out).replace(/\s+/g, '');

    // figure out the language
    let available_languages = { 'en-US': true, 'ar': true, 'de': true, 'es-ES': true, 'fa': true, 'fr': true, 'it': true, 'ko': true, 'nl': true, 'pl': true, 'pt-PT': true, 'ru': true, 'vi': true, 'zh-CN': true};
    this._language = GLib.getenv('LANG').split('.')[0].replace('_', '-');
    if(!available_languages[this._language]) {
      this._language = this._language.split('-')[0];
      if(!available_languages[this._language]) {
        for(let i in available_languages) {
          if(this._language.substring(0, 2) == available_languages[i]) {
            this._language = available_languages[i];
          }
        }
      }
    }
    // if language isn't available, default to english
    if(!available_languages[this._language]) {
      this._language = 'en-US';
    }
  },

  // build all relevant paths
  _build_paths: function(){
    let tbb_data = GLib.getenv('HOME')+'/.torbrowser';
    let tarball_filename = 'tor-browser-gnu-linux-'+this._architecture+'-'+this._current_tbb_version+'-dev-'+this._language+'.tar.gz';
    this._paths = {
      dir: {
        data: tbb_data,
        download: tbb_data+'/download',
        tbb: tbb_data+'/tbb/'+this._architecture
      },
      file: {
        version: tbb_data+'/version',
        start: tbb_data+'/tbb/'+this._architecture+'/tor-browser_'+this._language+'/start-tor-browser',
        tarball: tbb_data+'/download/'+tarball_filename,
        tarball_sig: tbb_data+'/download/'+tarball_filename+'.asc'
      },
      url: {
        tarball: 'https://www.torproject.org/dist/torbrowser/linux/'+tarball_filename,
        tarball_sig: 'https://www.torproject.org/dist/torbrowser/linux/'+tarball_filename+'.asc'
      },
      filename: {
        tarball: tarball_filename,
        tarball_sig: tarball_filename+'.asc'
      }
    };
  },

  // create directories that don't exist
  _mkdirs: function(){
    if(!this._file_exists(this._paths.dir.download)) {
      GLib.mkdir_with_parents(this._paths.dir.download, 0x1c0); // 0x1c0 is 0700
    }
    if(!this._file_exists(this._paths.dir.tbb)) {
      GLib.mkdir_with_parents(this._paths.dir.tbb, 0x1c0);
    }
  },

  // build the application's UI
  _build_ui: function() {
    let that = this;

    // create the application window
    this._window = new Gtk.ApplicationWindow({
      application: this.application,
      window_position: Gtk.WindowPosition.CENTER,
      border_width: 10,
      title: "Tor Browser Launcher"
    });

    // create the Grid
    this._grid = new Gtk.Grid ({
      row_spacing: 10,
      column_spacing: 20
    });

    switch(this._gui) {
      case 'error':
        // labels
        this._label1 = new Gtk.Label({ label: this._gui_message });
        this._label2 = new Gtk.Label({ 
          label: 
            "You can fix the problem by deleting:\n"+
            this._paths.dir.data+"\n\n"+
            "However, you will lose all your bookmarks and other\n"+
            "Tor Browser preferences."
        });

        // exit button
        this._button_exit = new Gtk.Button({ label: "Exit" });
        this._button_exit.connect('clicked', Lang.bind(this, function(){
          this._window.destroy();
        }));

        // attach everything to the grid
        this._grid.attach(this._label1, 0, 0, 1, 1);
        this._grid.attach(this._label2, 0, 1, 1, 1);
        this._grid.attach(this._button_exit, 0, 2, 1, 1);
        break;

      case 'task':
        // the label
        this._label = new Gtk.Label({ label: this._gui_message });

        // progress bar
        this._progress_bar = new Gtk.ProgressBar({
          orientation: Gtk.Orientation.HORIZONTAL
        });

        // download buttons
        this._button_start = new Gtk.Button({ label: "Start" });
        this._button_start.connect('clicked', Lang.bind(this, function(){
          // disable the start button
          this._button_start.set_sensitive(false);

          // make an array of functions to call in order
          let task_functions = [];
          for(let i = 0; i < this._gui_tasks.length; i++) {
            
            switch(this._gui_tasks[i]){
              case 'download_tarball':
                task_functions.push(function(done){
                  that._download_file('Tor Browser Bundle .tar.gz', that._paths.url.tarball, that._paths.file.tarball, function(err){
                    if(err) {
                      done(err);
                      return;
                    }
                    done();
                  });
                });
                break;
              case 'download_tarball_sig':
                task_functions.push(function(done){
                  that._download_file('Tor Browser Bundle .asc', that._paths.url.tarball_sig, that._paths.file.tarball_sig, function(err){
                    if(err) {
                      done(err);
                      return;
                    }
                    done();
                  });
                });
                break;
              case 'verify':
                task_functions.push(function(done){
                  that._verify(function(){
                    done();
                  });
                });
                break;

              case 'extract':
                task_functions.push(function(done){
                  that._extract(function(){
                    done();
                  });
                });
                break;
              case 'run':
                task_functions.push(function(done){
                  if(!that._exec([that._paths.file.start])) {
                    that._statusbar.label = 'Failed to execute '+that._paths.file.start;
                    that._button_start.set_sensitive(true);
                  };
                  done();
                });
                break;
            }
            
          }

          // call them in order
          let i = 0;
          function series(done){
            if(i == task_functions.length) {
              done();
            }

            task_functions[i](function(err){
              if(err) {
                // there was an error in the series
                // handle it by making the start button clickable again
                that._button_start.set_sensitive(true);
              } else {
                i++;
                series(done);
              }
            });
          };
          series(function(){
            // all tasks have been executed, so exit
            that._window.destroy();
          });

        }));

        // exit button
        this._button_exit = new Gtk.Button({ label: "Exit" });
        this._button_exit.connect('clicked', Lang.bind(this, function(){
          this._window.destroy();
        }));

        // status bar
        this._statusbar = new Gtk.Label({ });

        // attach everything to the grid
        this._grid.attach(this._label, 0, 0, 2, 1);
        this._grid.attach(this._progress_bar, 0, 1, 2, 1);
        this._grid.attach(this._button_start,  0, 2, 1, 1);
        this._grid.attach(this._button_exit, 1, 2, 1, 1);
        this._grid.attach(this._statusbar, 0, 3, 2, 1);
        break;
    }

    // add the grid to the window
    this._window.add(this._grid);
    this._window.show_all();
  },

  // there are different GUIs that might appear, this sets which one we want
  _set_gui: function(gui, message, tasks){
    this._gui = gui;
    this._gui_message = message;
    this._gui_tasks = tasks ? tasks : [];
  },

  // download a file, while updating the progress bar
  // callback is function(err)
  _download_file: function(name, url, path, callback){
    let that = this;
    this._statusbar.set_label('Downloading '+name);

    function file_size(bytes) {
      if(bytes < 1024) {
        return ''+bytes+' bytes';
      }
      let kb = bytes / 1024;
      kb = Math.floor(kb);
      if(kb < 1024) {
        return ''+kb+'kb';
      }
      let mb = kb / 1024;
      mb = Math.floor(mb * 100) / 100;
      return ''+mb+'mb';
    }

    let total_size;
    let bytes_so_far = 0;

    // create an http message
    let request = Soup.Message.new('GET', url);

    // grab the content-length from the headers
    request.connect('got_headers', Lang.bind(this, function(message){
      total_size = message.response_headers.get_content_length()
    }));
    
    // update progress bar with each chunk
    request.connect('got_chunk', Lang.bind(this, function(message, chunk){
      // todo: write chunk to file

      bytes_so_far += chunk.length;

      if(total_size) {
        let fraction = bytes_so_far / total_size;
        let percent = Math.floor(fraction * 100);
        this._progress_bar.set_fraction(fraction);
        this._statusbar.set_label("Downloading "+name+": "+percent+"% ("+file_size(bytes_so_far)+" / "+file_size(total_size)+")");
      }
    }));
    
    this._httpSession.queue_message(request, function(_httpSession, message) {
      if(message.status_code !== 200) {
        that._statusbar.set_label('Downloading '+name+' failed: '+message.status_code);
        callback(true);
        return;
      }
      that._progress_bar.set_fraction(1);
      that._statusbar.set_label('Downloading '+name+' finished');
      callback();
    });
  },
  
  // verify the signature on the tarball
  // callback is function(err)
  _verify: function(callback){
    // todo: verify signature
    callback();
  },

  // extract tbb over the old version, while updating the progress bar
  // callback is function(err)
  _extract: function(callback){
    let [res, out] = this._exec(['tar', '-xf', this._paths.file.tarball, '-C', this._paths.dir.tbb]);
    print(out);
    callback();
  },

  // read the version file
  // callback is function(err, version)
  _read_version_file: function(){
    let f = GLib.file_get_contents(this._paths.file.version);
    if(f && f[1]) {
      let version = f[1].replace(/\s+/g, ' ');
      return version;
    } else {
      return false;
    }
  },

  // write the version to the version file
  _write_version_file: function(version){
    // make sure version is a string
    version = ''+version;
    try {
      GLib.file_set_contents(this._paths.file.version, version, version.length);
      return true;
    } catch(err) {
      return err;
    }
  },

  // some wrapper functions, to make things less verbose
  _file_exists: function(filename){
    return GLib.file_test(filename, GLib.FileTest.EXISTS);
  },
  _file_executable: function(filename){
    return GLib.file_test(filename, GLib.FileTest.IS_EXECUTABLE);
  },
  _exec: function(args){
    try {
      return GLib.spawn_sync(null, args, null, GLib.SpawnFlags.SEARCH_PATH, null);
    } catch(err) {
      return false;
    }
  }
});

print('Tor Browser Launcher');
print('https://github.com/micahflee/torbrowser-launcher');

// run the application
let current_tbb_version = '2.3.25-2';
let app = new TorBrowserLauncher(current_tbb_version);

